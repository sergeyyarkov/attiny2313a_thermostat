
AVRASM ver. 2.2.7  main.asm Tue Jun 20 22:15:20 2023

[builtin](2): Including file '/home/sergeyyarkov/.mchp_packs/Microchip/ATtiny_DFP/3.0.151/avrasm/inc\tn2313Adef.inc'
main.asm(15): Including file 'definitions.asm'
main.asm(16): Including file 'macros.asm'
main.asm(275): Including file 'div16u.asm'
div16u.asm(22): warning: Register r16 already defined by the .DEF directive
main.asm(275): 'div16u.asm' included form here
div16u.asm(23): warning: Register r17 already defined by the .DEF directive
main.asm(275): 'div16u.asm' included form here
div16u.asm(24): warning: Register r16 already defined by the .DEF directive
main.asm(275): 'div16u.asm' included form here
div16u.asm(25): warning: Register r17 already defined by the .DEF directive
main.asm(275): 'div16u.asm' included form here
div16u.asm(27): warning: Register r19 already defined by the .DEF directive
main.asm(275): 'div16u.asm' included form here
div16u.asm(28): warning: Register r20 already defined by the .DEF directive
main.asm(275): 'div16u.asm' included form here
[builtin](2): Including file '/home/sergeyyarkov/.mchp_packs/Microchip/ATtiny_DFP/3.0.151/avrasm/inc\tn2313Adef.inc'
main.asm(15): Including file 'definitions.asm'
main.asm(16): Including file 'macros.asm'
main.asm(275): Including file 'div16u.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny2313A.xml *********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn2313Adef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny2313A
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny2313A
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN2313ADEF_INC_
                                 #define _TN2313ADEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny2313A
                                 #pragma AVRPART ADMIN PART_NAME ATtiny2313A
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x91
                                 .equ	SIGNATURE_002	= 0x0a
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2
                                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	OCR0B	= 0x3c
                                 .equ	GIMSK	= 0x3b
                                 .equ	EIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCSR	= 0x37
                                 .equ	OCR0A	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0B	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	TCCR0A	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	CLKPR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	GTCCR	= 0x23
                                 .equ	TCCR1C	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	PCMSK0	= 0x20
                                 .equ	EEAR	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	GPIOR2	= 0x15
                                 .equ	GPIOR1	= 0x14
                                 .equ	GPIOR0	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	USIDR	= 0x0f
                                 .equ	USISR	= 0x0e
                                 .equ	USICR	= 0x0d
                                 .equ	UDR	= 0x0c
                                 .equ	UCSRA	= 0x0b
                                 .equ	UCSRB	= 0x0a
                                 .equ	UBRRL	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	BODCR	= 0x07
                                 .equ	PRR	= 0x06
                                 .equ	PCMSK2	= 0x05
                                 .equ	PCMSK1	= 0x04
                                 .equ	UCSRC	= 0x03
                                 .equ	UBRRH	= 0x02
                                 .equ	DIDR	= 0x01
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0A	= 0	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0A	= 0	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Match Output B Mode
                                 .equ	COM0B1	= 5	; Compare Match Output B Mode
                                 .equ	COM0A0	= 6	; Compare Match Output A Mode
                                 .equ	COM0A1	= 7	; Compare Match Output A Mode
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	TCCR0	= TCCR0B	; For compatibility
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare B
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	ICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	TICIE	= ICIE1	; For compatibility
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1B0	= 4	; Comparet Ouput Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode Bit 2
                                 .equ	CTC1	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode Bit 3
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for Channel A
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART ************************
                                 ; UDR - USART I/O Data Register
                                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSRA - USART Control and Status Register A
                                 .equ	USR	= UCSRA	; For compatibility
                                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                                 .equ	U2X	= 1	; Double the USART Transmission Speed
                                 .equ	UPE	= 2	; USART Parity Error
                                 .equ	PE	= UPE	; For compatibility
                                 .equ	DOR	= 3	; Data overRun
                                 .equ	FE	= 4	; Framing Error
                                 .equ	UDRE	= 5	; USART Data Register Empty
                                 .equ	TXC	= 6	; USART Transmitt Complete
                                 .equ	RXC	= 7	; USART Receive Complete
                                 
                                 ; UCSRB - USART Control and Status Register B
                                 .equ	UCR	= UCSRB	; For compatibility
                                 .equ	TXB8	= 0	; Transmit Data Bit 8
                                 .equ	RXB8	= 1	; Receive Data Bit 8
                                 .equ	UCSZ2	= 2	; Character Size
                                 .equ	CHR9	= UCSZ2	; For compatibility
                                 .equ	TXEN	= 3	; Transmitter Enable
                                 .equ	RXEN	= 4	; Receiver Enable
                                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSRC - USART Control and Status Register C
                                 .equ	UCPOL	= 0	; Clock Polarity
                                 .equ	UCSZ0	= 1	; Character Size Bit 0
                                 .equ	UCSZ1	= 2	; Character Size Bit 1
                                 .equ	USBS	= 3	; Stop Bit Select
                                 .equ	UPM0	= 4	; Parity Mode Bit 0
                                 .equ	UPM1	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0 	= 6	; USART Mode Select 0
                                 .equ 	UMSEL1 	= 7 ; USART Mode Select 1
                                 .equ 	UCPHA  	= 1 ; USART MSPIM Clock Phase
                                 .equ 	UDORD  	= 2 ; USART MSPIM Data Order 
                                 
                                 .equ	UBRR	= UBRRL	; For compatibility
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; 
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Data Register, Port D
                                 .equ	PORTD0	= 0	; 
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; 
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; 
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; 
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; 
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; 
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; 
                                 .equ	PD6	= 6	; For compatibility
                                 
                                 ; DDRD - Data Direction Register, Port D
                                 .equ	DDD0	= 0	; 
                                 .equ	DDD1	= 1	; 
                                 .equ	DDD2	= 2	; 
                                 .equ	DDD3	= 3	; 
                                 .equ	DDD4	= 4	; 
                                 .equ	DDD5	= 5	; 
                                 .equ	DDD6	= 6	; 
                                 
                                 ; PIND - Input Pins, Port D
                                 .equ	PIND0	= 0	; 
                                 .equ	PIND1	= 1	; 
                                 .equ	PIND2	= 2	; 
                                 .equ	PIND3	= 3	; 
                                 .equ	PIND4	= 4	; 
                                 .equ	PIND5	= 5	; 
                                 .equ	PIND6	= 6	; 
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEAR - EEPROM Read/Write Access
                                 .equ	EEARL	= EEAR	; For compatibility
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access bit 6
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEWE	= EEPE	; For compatibility
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EEMWE	= EEMPE	; For compatibility
                                 .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; 
                                 .equ	EEPM1	= 5	; 
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 
                                 
                                 ; ***** USI **************************
                                 ; USIDR - USI Data Register
                                 .equ	USIDR0	= 0	; USI Data Register bit 0
                                 .equ	USIDR1	= 1	; USI Data Register bit 1
                                 .equ	USIDR2	= 2	; USI Data Register bit 2
                                 .equ	USIDR3	= 3	; USI Data Register bit 3
                                 .equ	USIDR4	= 4	; USI Data Register bit 4
                                 .equ	USIDR5	= 5	; USI Data Register bit 5
                                 .equ	USIDR6	= 6	; USI Data Register bit 6
                                 .equ	USIDR7	= 7	; USI Data Register bit 7
                                 
                                 ; USISR - USI Status Register
                                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                                 .equ	USIDC	= 4	; Data Output Collision
                                 .equ	USIPF	= 5	; Stop Condition Flag
                                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                                 
                                 ; USICR - USI Control Register
                                 .equ	USITC	= 0	; Toggle Clock Port Pin
                                 .equ	USICLK	= 1	; Clock Strobe
                                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ  PCIE1 = 3 ;
                                 .equ  PCIE2 = 4 ;
                                 .equ	PCIE0	= 5	; 
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - Extended Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	PCIF0	= 5	; 
                                 .equ  PCIF2	= 4   ;
                                 .equ  PCIF1   = 3   ;
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK2 - Pin Change Interrupt Mask Register 2
                                 .equ	PCINT11	= 0	; Pin Change Interrupt Mask 11
                                 .equ	PCINT12	= 1	; Pin Change Interrupt Mask 12
                                 .equ	PCINT13	= 2	; Pin Change Interrupt Mask 13
                                 .equ	PCINT14	= 3	; Pin Change Interrupt Mask 14
                                 .equ	PCINT15	= 4	; Pin Change Interrupt Mask 15
                                 .equ	PCINT16	= 5	; Pin Change Interrupt Mask 16
                                 .equ	PCINT17	= 6	; Pin Change Interrupt Mask 17
                                 
                                 ; PCMSK1 - Pin Change Interrupt Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Interrupt Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Interrupt Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Interrupt Mask 10
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	RFLB	= 3	; Read Fuse and Lock Bits
                                 .equ	CTPB	= 4	; Clear Temporary Page Buffer
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 0
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM0	= 4	; Sleep Mode Select Bit 0
                                 .equ	SM	= SM0	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SM1	= 6	; Sleep Mode Select Bit 1
                                 .equ	PUD	= 7	; Pull-up Disable
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Register
                                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                                 
                                 ; GTCCR - General Timer Counter Control Register
                                 .equ	SFIOR	= GTCCR	; For compatibility
                                 .equ	PSR10	= 0	; 
                                 
                                 ; PCMSK - Pin-Change Mask register
                                 .equ	PCINT0	= 0	; Pin-Change Interrupt 0
                                 .equ	PCINT1	= 1	; Pin-Change Interrupt 1
                                 .equ	PCINT2	= 2	; Pin-Change Interrupt 2
                                 .equ	PCINT3	= 3	; Pin-Change Interrupt 3
                                 .equ	PCINT4	= 4	; Pin-Change Interrupt 4
                                 .equ	PCINT5	= 5	; Pin-Change Interrupt 5
                                 .equ	PCINT6	= 6	; Pin-Change Interrupt 6
                                 .equ	PCINT7	= 7	; Pin-Change Interrupt 7
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; General Purpose I/O Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose I/O Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose I/O Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose I/O Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose I/O Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose I/O Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose I/O Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose I/O Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; General Purpose I/O Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose I/O Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose I/O Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose I/O Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose I/O Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose I/O Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose I/O Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose I/O Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; General Purpose I/O Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose I/O Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose I/O Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose I/O Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose I/O Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose I/O Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose I/O Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose I/O Register 0 bit 7
                                 
                                 ; PRR - Power reduction register
                                 .equ	PRUSART	= 0	; 
                                 .equ	PRUSI	= 1	; 
                                 .equ	PRTIM0	= 2	; 
                                 .equ	PRTIM1	= 3	; 
                                 
                                 ; BODCR - BOD control register
                                 .equ	BPDSE	= 0	; 
                                 .equ	BPDS	= 1	; 
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x03ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 128
                                 .equ	RAMEND	= 0x00df
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x007f
                                 .equ	EEPROMEND	= 0x007f
                                 .equ	EEADRBITS	= 7
                                 #pragma AVRPART MEMORY PROG_FLASH 2048
                                 #pragma AVRPART MEMORY EEPROM 128
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 128
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x0
                                 .equ	NRWW_STOP_ADDR	= 0x3ff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x0
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                                 .equ	ICP1addr	= 0x0003	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0004	; Timer/Counter1 Compare Match A
                                 .equ	OC1addr	= 0x0004	; For compatibility
                                 .equ	OVF1addr	= 0x0005	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0006	; Timer/Counter0 Overflow
                                 .equ	URXCaddr	= 0x0007	; USART, Rx Complete
                                 .equ	URXC0addr	= 0x0007	; For compatibility
                                 .equ	UDREaddr	= 0x0008	; USART Data Register Empty
                                 .equ	UDRE0addr	= 0x0008	; For compatibility
                                 .equ	UTXCaddr	= 0x0009	; USART, Tx Complete
                                 .equ	UTXC0addr	= 0x0009	; For compatibility
                                 .equ	ACIaddr	= 0x000a	; Analog Comparator
                                 .equ	PCIBaddr	= 0x000b	; Pin Change Interrupt Request B
                                 .equ	PCIaddr	= 0x000b	; For compatibility
                                 .equ	OC1Baddr	= 0x000c	; 
                                 .equ	OC0Aaddr	= 0x000d	; 
                                 .equ	OC0Baddr	= 0x000e	; 
                                 .equ	USI_STARTaddr	= 0x000f	; USI Start Condition
                                 .equ	USI_OVFaddr	= 0x0010	; USI Overflow
                                 .equ	ERDYaddr	= 0x0011	; 
                                 .equ	WDTaddr	= 0x0012	; Watchdog Timer Overflow
                                 .equ	PCIAaddr	= 0x0013	; Pin Change Interrupt Request A
                                 .equ	PCIDaddr	= 0x0014	; Pin Change Interrupt Request D
                                 
                                 .equ	INT_VECTORS_SIZE	= 21	; size in words
                                 
                                 #endif  /* _TN2313ADEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Project name: thermostat
                                 ; Description: Electronic thermostat on AVR Microcontroller
                                 ; Source code: https://github.com/sergeyyarkov/attiny2313a_thermostat
                                 ; Device: ATtiny2313A
                                 ; Device Datasheet: http://ww1.microchip.com/downloads/en/DeviceDoc/doc8246.pdf
                                 ; Assembler: AVR macro assembler 2.2.7
                                 ; Clock frequency: 8 MHz External Crystal Oscillator
                                 ; Fuses: lfuse: 0xCF, hfuse: 0x9F, efuse: 0xFF, lock: 0xFF
                                 ;
                                 ; Written by Sergey Yarkov 22.01.2023
                                 
                                 .LIST
                                 
                                 .INCLUDE "definitions.asm"
                                 
                                  
                                 .DEF TEMP_REG_A                 = r16
                                 .DEF TEMP_REG_B                 = r17
                                 .DEF DELAY_16_r			= r19
                                 .DEF DELAY_8_r			= r20
                                 .DEF DISP_NUM_L                 = r24		; LSB числа которое сейчас на индикаторе
                                 .DEF DISP_NUM_H                 = r25		; MSB числа которое сейчас на индикаторе
                                 
                                 .EQU DIGIT_1_PIN                = PD2		; Пин разряда индикатора 1
                                 .EQU DIGIT_2_PIN                = PD3		; Пин разряда индикатора 2
                                 .EQU DIGIT_3_PIN                = PD4		; Пин разряда индикатора 3
                                 .EQU DIGIT_4_PIN                = PD5		; Пин разряда индикатора 4
                                 
                                 .EQU LED_ERR_PIN		= PD6		; Светодиод который говорит о том, что МК в состоянии ошибки 
                                 
                                 .EQU OW_LINE			= PB1		; Пин шины 1-Wire
                                 .EQU OW_DDR			= DDRB
                                 .EQU OW_PIN			= PINB
                                 .DEF OW_CMD_r			= r8
                                 .DEF OWFR			= r23		; Флаги состояния для 1-Wire интерфейса
                                 .EQU OWPRF                      = 0		; 1-Wire Флаг присутствия
                                 .EQU OWSB                       = 1		; Флаг передачи одного бита
                                 
                                 ; **** КОМАНДЫ ДАТЧИКА *****************************************
                                 .EQU DS18B20_CMD_CONVERTTEMP    = 0x44
                                 .EQU DS18B20_CMD_RSCRATCHPAD    = 0xbe
                                 .EQU DS18B20_CMD_WSCRATCHPAD    = 0x4e
                                 .EQU DS18B20_CMD_CPYSCRATCHPAD  = 0x48
                                 .EQU DS18B20_CMD_RECEEPROM      = 0xb8
                                 .EQU DS18B20_CMD_RPWRSUPPLY     = 0xb4
                                 .EQU DS18B20_CMD_SEARCHROM      = 0xf0
                                 .EQU DS18B20_CMD_READROM        = 0x33
                                 .EQU DS18B20_CMD_MATCHROM       = 0x55
                                 .EQU DS18B20_CMD_SKIPROM        = 0xcc
                                 .EQU DS18B20_CMD_ALARMSEARCH    = 0xec
                                 
                                 .EQU USI_LATCH_PIN              = PB0		; ST_CP на 74HC595
                                 .EQU USI_DO_PIN                 = PB6		; DS на 74HC595
                                 .EQU USI_CLK_PIN                = PB7		; SH_CP на 74HC595
                                 
                                 .EQU SW_PORT                    = PORTB
                                 .EQU SW_PIN                     = PINB
                                 .EQU SW_PLUS_PIN                = PB2		; Кнопка "Минус"
                                 .EQU SW_MINUS_PIN               = PB3		; Кнопка "Плюс"
                                 .EQU SW_SET_PIN                 = PB4		; Кнопка "Установить"
                                     
                                 .EQU UART_RX_PIN		= PD0
                                 .EQU UART_TX_PIN		= PD1
                                     
                                 
                                 .EQU MCU_STATE_DEFAULT          = 0x00		; Режим измерения температуры и сравнения с заданными параметрами
                                 .EQU MCU_STATE_PROGRAM          = 0x01		; Режим настройки параметров в EEPROM
                                 .INCLUDE "macros.asm"
                                 
                                     ldi       @0, @2
                                     out       @1, @0
                                 .ENDMACRO
                                 
                                 .MACRO display_load
                                 
                                     ldi   DISP_NUM_L,    LOW(@0)
                                     ldi   DISP_NUM_H,    HIGH(@0)
                                 .ENDMACRO
                                 
                                 .MACRO ow_pull
                                     sbi       OW_DDR, OW_LINE
                                 .ENDMACRO
                                 
                                 .MACRO ow_release
                                     cbi       OW_DDR, OW_LINE
                                 .ENDMACRO
                                     
                                 .MACRO DELAY16
                                     ldi    DELAY_16_r, HIGH(@0*F_CPU/4-2)
                                     ldi    DELAY_8_r, LOW(@0*F_CPU/4-2)
                                     rcall DELAY_LOOP_16
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Сегмент данных">
                                 ; **** СЕГМЕНТ ДАННЫХ ********************************************
                                 .DSEG
                                 .ORG SRAM_START
                                 
000060                           MCU_STATE:      .BYTE 1                     ; Текущее состояние МК
000061                           SRAM_TEMP_1:    .BYTE 2                     ; Хранения временного 16-бит числа в ячейке
000063                           DIGITS:         .BYTE 4                     ; Ячейки, где хранятся символы, для вывода на индикатор
000067                           CURRENT_DIGIT:  .BYTE 1                     ; Номер разряда индикатора, который сейчас горит
000068                           SW_FLAGS:       .BYTE 1                     ; Состояние кнопок
000069                           HYSTERESIS:     .BYTE 1                     ; Отклонение температуры от уставки
00006a                           TEMP_L:		.BYTE 1			    ; Младший байт температуры
00006b                           TEMP_H:		.BYTE 1			    ; Старший байт температуры
00006c                           TEMP_F:		.BYTE 1			    ; Дробная часть
                                 ;//</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Сегмент кода">
                                 ; **** СЕГМЕНТ КОДА **********************************************
                                 .CSEG
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Вектора">
                                 .ORG 0x00     
000000 c069                          rjmp 	RESET_vect
                                     
                                 .ORG 0x000B
                                 ;    rjmp  PCINT0_vect
00000b 9518                          reti
                                 
                                 .ORG 0x000D   
00000d c015                          rjmp	TIMER0_COMPA_vect
                                 //</editor-fold>
                                     
                                 //<editor-fold defaultstate="collapsed" desc="Прерывание: изменение состояния пина">
                                 PCINT0_vect:
00000e 930f                          push    r16
00000f 931f                          push    r17
000010 932f                          push    r18
000011 933f                          push    r19
000012 b70f                          in	    r16, SREG
                                     
                                 ;    in	    r17, SW_PIN
                                 ;    clr	    r18
                                 ;    ldi	    r18, (1<<SW_PLUS_PIN) | (1<<SW_MINUS_PIN)
                                 ;    and	    r17, r18
                                 ;    cp	    r17, r18
                                 ;    breq    _PCINT0_vect_end
000013 99b4                          sbic    SW_PIN, SW_SET_PIN
000014 c008                          rjmp    _PCINT0_vect_end
                                     
000015 9120 0060                     lds	    r18, MCU_STATE
000017 3020                          cpi	    r18, MCU_STATE_DEFAULT
000018 f009                          breq    _INTO_PROGRAM_STATE
000019 c003                          rjmp    _PCINT0_vect_end
                                     
                                 _INTO_PROGRAM_STATE:
00001a e011                          ldi	    r17, MCU_STATE_PROGRAM
00001b 9310 0060                     sts	    MCU_STATE, r17
                                     
                                 _PCINT0_vect_end:
00001d bf0f                          out	    SREG, r16
00001e 913f                          pop	    r19
00001f 912f                          pop	    r18
000020 911f                          pop	    r17
000021 910f                          pop	    r16
000022 9518                          reti//</editor-fold>
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Прерывание: динамическая индикация">
                                 ; **** ДИНАМИЧЕСКАЯ ИНДИКАЦИЯ ************************************
                                 TIMER0_COMPA_vect:
000023 934f                          push      r20
000024 935f                          push      r21
000025 930f                          push      r16
000026 b75f                          in r21, SREG
                                 
000027 9140 0067                     lds       r20,  CURRENT_DIGIT
000029 3045                          cpi       r20,  5
00002a f40c                          brge      _CLR_CURRENT_DIGIT          ; сброс активного разряда если >= 5
00002b c003                          rjmp      _indicate_1
                                 
                                 _CLR_CURRENT_DIGIT:                   ; сброс текущего активного разряда в ноль
00002c 2744                          clr     r20
00002d 9340 0067                     sts     CURRENT_DIGIT, r20
                                 
                                 _indicate_1:
00002f 3040                          cpi       r20, 0
000030 f481                          brne      _indicate_2
                                 
000031 9893                          cbi       PORTD, DIGIT_2_PIN
000032 9894                          cbi       PORTD, DIGIT_3_PIN
000033 9895                          cbi       PORTD, DIGIT_4_PIN
                                 ;    lds       TEMP_REG_A, DIGITS+2
000034 f00e                          brts      PC+2
000035 c002                          rjmp      PC+3
000036 e00b                          ldi	      TEMP_REG_A, 11 ; // -
000037 c002                          rjmp      PC+3
000038 9100 0065                     lds	      TEMP_REG_A, DIGITS+2
00003a 2300                          tst	      TEMP_REG_A
00003b f011                          breq      PC+3
00003c 9a92                          sbi       PORTD, DIGIT_1_PIN
00003d c001                          rjmp      PC+2
00003e 9892                          cbi       PORTD, DIGIT_1_PIN
                                 ;    lds       TEMP_REG_A, DIGITS+2
00003f d169                          rcall     DISPLAY_DECODER
000040 d0e4                          rcall     USI_TRANSMIT
                                 
                                 _indicate_2:
000041 3041                          cpi       r20, 1
000042 f441                          brne      _indicate_3
                                 
000043 9892                          cbi       PORTD, DIGIT_1_PIN
000044 9894                          cbi       PORTD, DIGIT_3_PIN
000045 9895                          cbi       PORTD, DIGIT_4_PIN
                                 ;    lds       TEMP_REG_A, DIGITS+1
                                 ;    tst	      TEMP_REG_A
                                 ;    breq      PC+3
000046 9a93                          sbi       PORTD, DIGIT_2_PIN
                                 ;    rjmp      PC+2
                                 ;    cbi       PORTD, DIGIT_1_PIN
000047 9100 0064                     lds       TEMP_REG_A, DIGITS+1
000049 d15f                          rcall     DISPLAY_DECODER
00004a d0da                          rcall     USI_TRANSMIT
                                 
                                 _indicate_3:
00004b 3042                          cpi       r20, 2
00004c f459                          brne      _indicate_4
                                 
00004d 9892                          cbi       PORTD, DIGIT_1_PIN
00004e 9893                          cbi       PORTD, DIGIT_2_PIN
00004f 9895                          cbi       PORTD, DIGIT_4_PIN
000050 9a94                          sbi       PORTD, DIGIT_3_PIN
000051 9100 0063                     lds       TEMP_REG_A, DIGITS
000053 d155                          rcall     DISPLAY_DECODER
                                     ; зажигаем точку
000054 2d00                          mov	      r16, r0
000055 770f                          cbr	      r16, (1<<7)
000056 2e00                          mov	      r0, r16
000057 d0cd                          rcall     USI_TRANSMIT
                                 
                                 _indicate_4:
000058 3043                          cpi       r20, 3
000059 f441                          brne      _indicate_exit
                                 
00005a 9892                          cbi       PORTD, DIGIT_1_PIN
00005b 9893                          cbi       PORTD, DIGIT_2_PIN
00005c 9894                          cbi       PORTD, DIGIT_3_PIN
00005d 9a95                          sbi       PORTD, DIGIT_4_PIN
00005e 9100 006c                     lds       TEMP_REG_A, TEMP_F
000060 d148                          rcall     DISPLAY_DECODER
000061 d0c3                          rcall     USI_TRANSMIT
                                 
                                 _indicate_exit:
000062 9543                          inc       r20
000063 9340 0067                     sts       CURRENT_DIGIT, r20
000065 bf5f                          out SREG, r21
                                     
000066 910f                          pop r16
000067 915f                          pop r21
000068 914f                          pop r20
000069 9518                          reti
                                 ;//</editor-fold>
                                 
                                 ; **** СТАРТ ПРОГРАММЫ *******************************************
                                 RESET_vect:
00006a ed0f                          ldi       TEMP_REG_A, LOW(RAMEND)
00006b bf0d                          out       SPL, TEMP_REG_A
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Инициализация МК (настрока портов и переферии)">
                                 ; **** ПРОЦЕСС ИНИЦИАЛИЗАЦИИ МК **********************************
                                 MCU_INIT:
                                   ; **** ИНИЦИАЛИЗАЦИЯ ПИНОВ *************************************
00006c e70e
00006d bb01                        outi      r16, DDRD, (1<<LED_ERR_PIN) | (1<<DIGIT_1_PIN) | (1<<DIGIT_2_PIN) | (1<<DIGIT_3_PIN) | (1<<DIGIT_4_PIN) | (0<<UART_RX_PIN) | (1<<UART_TX_PIN)
00006e ec01
00006f bb07                        outi      r16, DDRB, (1<<USI_CLK_PIN) | (1<<USI_DO_PIN) | (1<<USI_LATCH_PIN) | (0<<SW_PLUS_PIN) | (0<<SW_MINUS_PIN) | (0<<SW_SET_PIN)
000070 e10c
000071 bb08                        outi      r16, PORTB, (1<<SW_PLUS_PIN) | (1<<SW_MINUS_PIN) | (1<<SW_SET_PIN)
                                   
                                   ; **** ИНИЦИАЛИЗАЦИЯ ТАЙМЕРА 0 **********************************
000072 e002
000073 bf00                        outi      r16, TCCR0A, (1<<WGM01)             ; режим CTC Compare A
000074 e005
000075 bf03                        outi      r16, TCCR0B, (1<<CS02) | (1<<CS00)  ; 1024 делитель
000076 e109
000077 bf06                        outi      r16, OCR0A, 25                      ; число для сравнения. (60Hz)
000078 e001
000079 bf09                        outi      r16, TIMSK, (1<<OCIE0A)             ; включение прерывания по совпадению
                                   
                                   ; **** ПРЕРЫВАНИЕ ПО ИЗМЕНЕНИЮ СОСТОЯНИЯ ПИНОВ ******************
00007a e200
00007b bf0b                        outi      r16, GIMSK, (1<<PCIE0)
00007c e10c
00007d bd00                        outi      r16, PCMSK0, (1<<PCINT2) | (1<<PCINT3) | (1<<PCINT4)          ; для кнопок
                                 
                                   ; **** ИНИЦИАЛИЗАЦИЯ USART **************************************
00007e e303
00007f b909                         outi      r16, UBRRL, LOW(51)			    ; 9600 БОД
000080 e000
000081 b902                         outi      r16, UBRRH, HIGH(51)		    ; 9600 БОД
000082 e108
000083 b90a                         outi      r16, UCSRB, (1<<RXEN) | (1<<TXEN)	    ; Включение приема и передачии
000084 e006
000085 b903                         outi      r16, UCSRC, (1<<UCSZ1) | (1<<UCSZ0)    ; Асинхронный режим, 8 бит фрейм, 1 стоповый бит
                                    
                                    
                                 continue:
000086 2411                          clr       r1
000087 9210 0067                     sts       CURRENT_DIGIT,  r1
                                 
000089 e000                          ldi       r16, 0x00
00008a 9300 0060                     sts       MCU_STATE,      r16	    ; переводим МК сразу в режим измерения температуры
                                     
00008c 2700                          clr	    r16
00008d 9300 006a                     sts	    TEMP_L, r16
00008f 9300 006b                     sts	    TEMP_H, r16
000091 ef00                          ldi r16, 0xf0
000092 9300 006c                     sts	    TEMP_F, r16
                                         
                                 
000094 e080
000095 e090                          display_load 0			    ; загружаем число, которое нужно показать на индикатор
                                     
                                 ;    sei
                                 //</editor-fold>
                                     
                                 //<editor-fold defaultstate="collapsed" desc="Главный цикл">
                                 ; **** ГЛАВНЫЙ ЦИКЛ **********************************************
                                 LOOP:
                                   ; rcall       DISPLAY_UPD_DIGITS
000096 9100 0060                     lds         r16, MCU_STATE           ; получаем текущее состояние МК
                                 
                                 _STATE_DEFAULT:
000098 3000                          cpi		r16, MCU_STATE_DEFAULT
000099 f479                          brne	_STATE_PROGRAM
00009a d0f4                          rcall	DISPLAY_UPD_DIGITS
00009b fd70                          sbrc	OWFR, OWPRF
00009c 9a96                          sbi		PORTD, PD6
00009d ff70                          sbrs	OWFR, OWPRF
00009e 9896                          cbi		PORTD, PD6
                                     
00009f d07b                          rcall	TEMP_CONV
0000a0 d113                          rcall	DEBOUNCE_SW
0000a1 d112                          rcall	DEBOUNCE_SW
0000a2 d02e                          rcall	TEMP_RD
                                         
0000a3 9110 006a                     lds		r17, TEMP_L
0000a5 2f81                          mov		DISP_NUM_L, r17
0000a6 9110 006b                     lds		r17, TEMP_H
0000a8 2f91                          mov		DISP_NUM_H, r17
                                     
                                 _STATE_PROGRAM:
0000a9 3001                          cpi       r16, MCU_STATE_PROGRAM
0000aa f411                          brne      _STATE_ERROR
0000ab d0e3                          rcall     DISPLAY_UPD_DIGITS
0000ac d084                          rcall     SW_CHECK_PROCESS
                                 _STATE_ERROR:
0000ad 3002                          cpi       r16, MCU_STATE_ERROR
0000ae f739                          brne      LOOP
0000af e01b                          ldi r17, 11
0000b0 9310 0063                     sts DIGITS, r17
0000b2 9310 0064                     sts DIGITS+1, r17
0000b4 9310 0065                     sts DIGITS+2, r17
0000b6 9310 0066                     sts DIGITS+3, r17
0000b8 0000                          nop
                                 
0000b9 cfdc                          rjmp      LOOP
                                 //</editor-fold>
                                 
                                 
                                 ; **** ПОДПРОГРАММЫ **********************************************
                                 .INCLUDE "div16u.asm"
                                 
                                 ;*
                                 ;* "div16u" - 16/16 Bit Unsigned Division
                                 ;*
                                 ;* This subroutine divides the two 16-bit numbers 
                                 ;* "dd8uH:dd8uL" (dividend) and "dv16uH:dv16uL" (divisor). 
                                 ;* The result is placed in "dres16uH:dres16uL" and the remainder in
                                 ;* "drem16uH:drem16uL".
                                 ;*  
                                 ;* Number of words	:19
                                 ;* Number of cycles	:235/251 (Min/Max)
                                 ;* Low registers used	:2 (drem16uL,drem16uH)
                                 ;* High registers used  :5 (dres16uL/dd16uL,dres16uH/dd16uH,dv16uL,dv16uH,
                                 ;*			    dcnt16u)
                                 ;*
                                 ;***************************************************************************
                                 
                                 ;***** Subroutine Register Variables
                                 
                                 .def	drem16uL=r14
                                 .def	drem16uH=r15
                                 .def	dres16uL=r16
                                 .def	dres16uH=r17
                                 .def	dd16uL	=r16
                                 .def	dd16uH	=r17
                                 .def	dv16uL	=r18
                                 .def	dv16uH	=r19
                                 .def	dcnt16u	=r20
                                 
                                 ;***** Code
                                 
                                 div16u:
0000ba 24ee                          clr			drem16uL								; clear remainder Low byte
0000bb 18ff                          sub			drem16uH,drem16uH				; clear remainder High byte and carry
0000bc e141                          ldi			dcnt16u,17							; init loop counter
                                 d16u_1:	
0000bd 1f00                          rol			dd16uL									; shift left dividend
0000be 1f11                          rol			dd16uH
0000bf 954a                          dec			dcnt16u									; decrement counter
0000c0 f409                          brne		d16u_2									; if done
0000c1 9508                          ret															; return
                                 d16u_2:	
0000c2 1cee                          rol			drem16uL								; shift dividend into remainder
0000c3 1cff                          rol			drem16uH
0000c4 1ae2                          sub			drem16uL,dv16uL					; remainder = remainder - divisor
0000c5 0af3                          sbc			drem16uH,dv16uH
0000c6 f420                          brcc		d16u_3									; if result negative
0000c7 0ee2                          add			drem16uL,dv16uL					; restore remainder
0000c8 1ef3                          adc			drem16uH,dv16uH
0000c9 9488                          clc															; clear carry to be shifted into result
0000ca cff2                          rjmp		d16u_1									; else
                                 d16u_3:	
0000cb 9408                          sec															; set carry to be shifted into result
0000cc cff0                          
                                 DELAY_LOOP_16:
0000cd 5041                          subi DELAY_8_r, 1
0000ce 4030                          sbci DELAY_16_r, 0
0000cf f7e8                          brcc DELAY_LOOP_16
0000d0 9508                          ret
                                     
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: чтение и опрос температуры">
                                 TEMP_RD:
0000d1 930f                          push	r16
0000d2 931f                          push	r17
0000d3 932f                          push	r18
0000d4 933f                          push	r19
0000d5 934f                          push	r20
                                 ;    cli
                                     
0000d6 d068                          rcall	OW_PRESENCE
0000d7 ec0c                          ldi		r16, DS18B20_CMD_SKIPROM
0000d8 2e80                          mov		OW_CMD_r, r16
0000d9 d07a                          rcall	OW_SEND_BYTE
                                     
0000da eb0e                          ldi		r16, DS18B20_CMD_RSCRATCHPAD
0000db 2e80                          mov		OW_CMD_r, r16
0000dc d077                          rcall	OW_SEND_BYTE
                                     
0000dd e6aa                          ldi		XL, LOW(TEMP_L)
0000de e0b0                          ldi		XH, HIGH(TEMP_L)
0000df d095                          rcall	OW_RD_BYTE
                                     
0000e0 e6ab                          ldi		XL, LOW(TEMP_H)
0000e1 e0b0                          ldi		XH, HIGH(TEMP_H)
0000e2 d092                          rcall	OW_RD_BYTE
                                     
0000e3 9110 006a                     lds		r17, TEMP_L
0000e5 9120 006b                     lds		r18, TEMP_H
                                     
0000e7 932f                          push	r18
0000e8 7f28                          cbr		r18, (1<<0) | (1<<1) | (1<<2)	; убираем ненужные биты на время (интересуют последних битов в TEMP_H)
0000e9 3f28                          cpi		r18, 0xf8			; проверяется является ли число минусовой
0000ea f011                          breq	_TEMP_RD_TO_UNSIGNED		; если да то конвертируем в беззнаковое число
0000eb 94e8                          clt
0000ec c009                          rjmp	_TEMP_RD_CONTINUE		; если нет то преобразуем значение АЦП в температуру (делим на 16)
                                 
                                 _TEMP_RD_TO_UNSIGNED:
0000ed 912f                          pop		r18
0000ee 9468                          set
0000ef 9510                          com	r17
0000f0 9520                          com	r18
0000f1 e031                          ldi	    r19, 1
0000f2 0f13                          add	    r17, r19
0000f3 e030                          ldi	    r19, 0
0000f4 1f23                          adc	    r18, r19
0000f5 c001                          rjmp    PC+2
                                     
                                 _TEMP_RD_CONTINUE:			    ; Температура = Число с АЦП / 16 (сдвиг вправо 4)
0000f6 912f                          pop		r18
0000f7 9526                          lsr r18
0000f8 9517                          ror r17
0000f9 9526                          lsr r18
0000fa 9517                          ror r17
0000fb 9526                          lsr r18
0000fc 9517                          ror r17
0000fd 9526                          lsr r18
0000fe 9517                          ror r17
                                 _TEMP_RD_END: 
0000ff 9130 006a                     lds	    r19, TEMP_L
000101 f40e                          brtc    PC+2
000102 9531                          neg	    r19				    ; переводим в беззнаковое число если минус
                                     
                                     ; далее происходит такое для получения дробной части: 
                                     ; ((n<<3) + (n<<1))>>4 или (n*10)/16
000103 2f43                          mov	    r20, r19
000104 703f                          andi    r19, 0x0f
000105 2f43                          mov	    r20, r19
000106 0f33                          lsl	    r19
000107 0f33                          lsl	    r19
000108 0f33                          lsl	    r19
                                     
000109 0f44                          lsl	    r20
                                     
00010a 0f34                          add	    r19, r20
                                     
00010b 9536                          lsr	    r19
00010c 9536                          lsr	    r19
00010d 9536                          lsr	    r19
00010e 9536                          lsr	    r19
                                     
                                     ; записываем данные
00010f 9310 006a                     sts		TEMP_L, r17
000111 9320 006b                     sts		TEMP_H, r18
000113 9330 006c                     sts		TEMP_F, r19
                                     
                                 ;    sei
000115 914f                          pop		r20
000116 913f                          pop		r19
000117 912f                          pop		r18
000118 911f                          pop		r17
000119 910f                          pop		r16
00011a 9508                          ret
                                 ;    
                                 TEMP_CONV:
00011b 930f                          push	r16
                                 ;    cli
                                     
00011c d022                          rcall	OW_PRESENCE
00011d ec0c                          ldi		r16, DS18B20_CMD_SKIPROM
00011e 2e80                          mov		OW_CMD_r, r16
00011f d034                          rcall	OW_SEND_BYTE
                                     
000120 e404                          ldi		r16, DS18B20_CMD_CONVERTTEMP
000121 2e80                          mov		OW_CMD_r, r16
000122 d031                          rcall	OW_SEND_BYTE
                                     
                                 ;    sei
000123 910f                          pop		r16
000124 9508                          ret
                                 //</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: отправка байта в сдвиговый регистр">
                                 ; **** ОТПРАВКА БАЙТА В СДВИГОВЫЙ РЕГИСТР *************************
                                 USI_TRANSMIT:
000125 930f                          push      r16
000126 b80f                          out       USIDR, r0            ; Байт для отправки всегда находится в регистре r0. Помещаем данные в регистр USIDR.
                                 
                                   ; Enable USI Overflow Interrupt Flag (will be 0 if transfer is not compeleted)
000127 e400                          ldi       TEMP_REG_A, (1<<USIOIF)      
000128 b90e                          out       USISR, TEMP_REG_A
                                   
                                   ; Load settings of USI into temp register
                                   ; This will setup USI to Three-wire mode, Software clock strobe (USITC) 
                                   ; with External, positive edge and toggle USCK
                                   ;
                                   ; USIWM0 <--------------> USI Wire Mode
                                   ; USICS1 <--------------> USI Clock Source Select
                                   ; USICLK <--------------> USI Clock Strobe
                                   ; USITC  <--------------> USI Toggle Clock (Enable clock generation)      
000129 e10b                          ldi       TEMP_REG_A, (1<<USIWM0) | (1<<USICS1) | (1<<USICLK) | (1<<USITC)
                                   
                                 _USI_TRANSMIT_LOOP:             ; Execute loop when USIOIF is 0
00012a b90d                          out       USICR, TEMP_REG_A   ; Load settings from temp register into USI Control Register
00012b 9b76                          sbis      USISR, USIOIF       ; If transfer is comleted then move out of loop
00012c cffd                          rjmp      _USI_TRANSMIT_LOOP
                                 
                                   ; Send pulse into LATCH pin. 
                                   ; This will copy byte from 74hc595 shift register into 74hc595 storage register
00012d 9ac0                          sbi      PORTB, USI_LATCH_PIN
00012e 98c0                          cbi      PORTB, USI_LATCH_PIN
00012f 910f                          pop      r16
000130 9508                          ret//</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: опрос кнопок">
                                 SW_CHECK_PROCESS:
000131 930f                          push    r16
000132 d081                          rcall   DEBOUNCE_SW
000133 9bb2                          sbis    SW_PIN, SW_PLUS_PIN
000134 9601                          adiw    DISP_NUM_L, 1
                                 
000135 9bb3                          sbis    SW_PIN, SW_MINUS_PIN
000136 9701                          sbiw    DISP_NUM_L, 1
                                     
000137 9bb4                          sbis    SW_PIN, SW_SET_PIN
000138 c001                          rjmp    _INTO_DEFAULT_STATE
000139 c003                          rjmp    _SW_CHECK_PROCESS_END
                                     
                                 _INTO_DEFAULT_STATE:
00013a e000                          ldi	    r16, MCU_STATE_DEFAULT
00013b 9300 0060                     sts	    MCU_STATE, r16
                                 _SW_CHECK_PROCESS_END:
00013d 910f                          pop	    r16
00013e 9508                          ret
                                 //</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Реализация интерфеса 1-Wire">
                                 //<editor-fold defaultstate="collapsed" desc="1-Wire: оспрос присутствия">
                                 ; **** ОПРОС ПРИСУТСТВИЯ УСТРОЙСТВА ******************************
                                 OW_PRESENCE:
00013f 94f8                          cli
000140 9ab9                          ow_pull
000141 e033
000142 eb4e
000143 df89                          DELAY16	480
000144 98b9                          ow_release
000145 e030
000146 e84a
000147 df85                          DELAY16	70
000148 d005                          rcall	OW_CHECK_PRESENCE
000149 e033
00014a e342
00014b df81                          DELAY16	410
00014c 9478                          sei
00014d 9508                          ret
                                 //</editor-fold>
                                 
                                 //<editor-fold defaultstate="collapsed" desc="1-Wire: проверка наличия устройства">
                                 ; **** ПРОВЕРКА НАЛИЧИЯ УСТРОЙСТВА *******************************
                                 ; Если подчиненное устройство притянет шину, то устанавливаем флаг OWPRF в единицу в регистре флагов
                                 ;
                                 OW_CHECK_PRESENCE:
00014e 9bb1                          sbis    OW_PIN, OW_LINE
00014f 6071                          sbr	    OWFR, (1<<OWPRF)
000150 c002                          rjmp    _EXIT
000151 99b1                          sbic    OW_PIN, OW_LINE
000152 7f7e                          cbr	    OWFR, (1<<OWPRF)
                                 _EXIT:
000153 9508                          ret
                                 //</editor-fold>
                                 
                                 //<editor-fold defaultstate="collapsed" desc="1-Wire: отправка байта">
                                 OW_SEND_BYTE:
000154 930f                          push    r16
000155 931f                          push    r17    
000156 2d08                          mov	    r16, OW_CMD_r
000157 e018                          ldi	    r17, 8
                                 _OW_SEND_BYTE_LOOP:
000158 9506                          lsr	    r16
000159 f408                          brcc    _OW_SEND_0
00015a f058                          brcs    _OW_SEND_1
                                 _OW_SEND_0:
00015b 94f8                          cli
00015c 9ab9                          ow_pull
00015d e030
00015e e746
00015f df6d                          DELAY16 60
000160 98b9                          ow_release
000161 e030
000162 e142
000163 df69                          DELAY16 10
000164 9478                          sei
000165 c00a                          rjmp    _OW_SEND_BYTE_END
                                 _OW_SEND_1:
000166 94f8                          cli
000167 9ab9                          ow_pull
000168 e030
000169 e04a
00016a df62                          DELAY16 6
00016b 98b9                          ow_release
00016c e030
00016d e74e
00016e df5e                          DELAY16 64
00016f 9478                          sei
                                 _OW_SEND_BYTE_END:
000170 951a                          dec	    r17
000171 f731                          brne    _OW_SEND_BYTE_LOOP
000172 911f                          pop	    r17
000173 910f                          pop	    r16
000174 9508                          ret
                                 //</editor-fold>
                                         
                                 //<editor-fold defaultstate="collapsed" desc="1-Wire: чтение байта">
                                 OW_RD_BYTE:
000175 930f                          push    r16
000176 931f                          push    r17
000177 2700                          clr	    r16
000178 e018                          ldi	    r17, 8
000179 94f8                          cli
                                 _OW_RD_BYTE_LP:
00017a 9506                          lsr	    r16
00017b 9ab9                          ow_pull
00017c e030
00017d e04a
00017e df4e                          DELAY16	6
00017f 98b9                          ow_release
000180 e030
000181 e140
000182 df4a                          DELAY16	9
000183 99b1                          sbic    OW_PIN, OW_LINE
000184 6800                          sbr	    r16, (1<<7)
000185 e030
000186 e64c
000187 df45                          DELAY16	55
000188 951a                          dec	    r17
000189 f781                          brne    _OW_RD_BYTE_LP
00018a 930c                          st	    X, r16
00018b 9478                          sei
00018c 911f                          pop	    r17
00018d 910f                          pop	    r16
00018e 9508                          ret
                                 //</editor-fold>
                                 
                                 
                                 //</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: обновление ячеек в SRAM для индикатора">
                                 ; **** ПОЛУЧЕНИЕ ЦИФР ИЗ 16-ТИ БИТНОГО ЧИСЛА *********************
                                 ; Описание: Перемещает цифры числа в соответствующие ячейки памяти в SRAM
                                 ;           путем деления этого числа несколько раз
                                 DISPLAY_UPD_DIGITS:
00018f 94f8                          cli
000190 935f                          push  r21
000191 e054                          ldi   r21,    4                     ; (4 раза делим) т.к индикатор четырех разрядный
                                   
                                   ; инициализация указателя (за каждый проход цикла будет инкрементироваться)
000192 e6a3                          ldi   XL, LOW(DIGITS)
000193 e0b0                          ldi   XH, HIGH(DIGITS)
                                 
                                     .equ  dividend      = SRAM_TEMP_1   ; число которе будем делить
                                     .equ  divisor       = 10            ; на что делим
                                 
                                   ; загружаем число которое хотим поделить в адрес SRAM делимого
000194 9380 0061                     sts   dividend,     DISP_NUM_L
000196 9390 0062                     sts   dividend+1,   DISP_NUM_H
                                 
                                   ; четыре раза производим деление для получения остатков
                                 DIV_LOOP:
                                     ; заполняем нужные регистры
000198 9100 0061                     lds   dd16uL, dividend
00019a 9110 0062                     lds   dd16uH, dividend+1
00019c e02a                          ldi   dv16uL, LOW(divisor)
00019d e030                          ldi   dv16uH, HIGH(divisor)
                                     
00019e df1b                          rcall div16u                      ; делим
                                 
00019f 92ed                          st   X+,    drem16uL              ; сохраняем остаток в ячейку по указателю и увеличиваем его
                                 
                                     ; обновляем делимое
0001a0 9300 0061                     sts  dividend,   dres16uL
0001a2 9310 0062                     sts  dividend+1, dres16uH
                                 
0001a4 955a                          dec   r21                         ; декрементируем счетчик цикла
0001a5 f791                          brne  DIV_LOOP                    ; делим еще раз если не 0
0001a6 915f                          pop   r21
0001a7 9478                          sei
0001a8 9508                          ret
                                 //</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: получение символа для индикатора">
                                 ; **** ЗАГРУЖАЕТ НУЖНЫЙ АДРЕС СИМВОЛА В R0 ***********************
                                 DISPLAY_DECODER:
0001a9 930f                          push     r16
0001aa 931f                          push     r17
0001ab eae4                          ldi	     ZL, LOW(2*DISPLAY_SYMBOLS)
0001ac e0f3                          ldi	     ZH, HIGH(2*DISPLAY_SYMBOLS)
                                 
0001ad 2711                          clr      TEMP_REG_B
0001ae 0fe0                          add      ZL, TEMP_REG_A
0001af 1ff1                          adc      ZH, TEMP_REG_B
                                 
0001b0 9004                          lpm      r0, Z
0001b1 911f                          pop      r17
0001b2 910f                          pop      r16
0001b3 9508                          ret//</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: устранение дребезга кнопки">
                                 DEBOUNCE_SW:
0001b4 930f                          push    r16
0001b5 931f                          push    r17
0001b6 932f                          push    r18
                                 
0001b7 e02a                          ldi	    r18, 10
                                 _loop_2:
0001b8 ef1f                          ldi     r17, 255
                                 _loop_0:
0001b9 ef0f                          ldi     r16, 255
                                 _dec_0:
0001ba 950a                          dec     r16
0001bb f7f1                          brne    _dec_0
                                 _loop_1:
0001bc 951a                          dec     r17
0001bd f7d9                          brne    _loop_0
                                 _loop_3:
0001be 952a                          dec	    r18
0001bf f7c1                          brne    _loop_2
                                 
0001c0 912f                          pop	    r18
0001c1 911f                          pop	    r17
0001c2 910f                          pop	    r16
0001c3 9508                          ret//</editor-fold>
                                 
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Подпрограмма: задержка">
                                 DELAY:
0001c4 930f                          push    r16
0001c5 931f                          push    r17
                                 
0001c6 ef0f                          ldi     r16, 255
                                 _DELAY_1:
0001c7 ef1f                          ldi     r17, 255   
                                 _DELAY_2:
0001c8 951a                          dec     r17         
0001c9 0000                          nop                 
0001ca 0000                          nop                
0001cb 0000                          nop                 
0001cc f7d9                          brne    _DELAY_2    
                                 
0001cd 950a                          dec     r16
0001ce f7c1                          brne    _DELAY_1    
                                 
0001cf 911f                          pop     r17
0001d0 910f                          pop     r16
0001d1 9508                          ret  //</editor-fold>
                                                   
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Символы для индикатора">
                                 DISPLAY_SYMBOLS:
                                       ; HGFEDCBA    HGFEDCBA
0001d2 f9c0                          .DB 0b11000000, 0b11111001          ; 0, 1
0001d3 b0a4                          .DB 0b10100100, 0b10110000          ; 2, 3
0001d4 9299                          .DB 0b10011001, 0b10010010          ; 4, 5
0001d5 f882                          .DB 0b10000010, 0b11111000          ; 6, 7
0001d6 9080                          .DB 0b10000000, 0b10010000          ; 8, 9
0001d7 bf9c                          .DB 0b10011100, 0b10111111          ; °, -//</editor-fold>
                                 
                                 //</editor-fold>
                                 
                                 //<editor-fold defaultstate="collapsed" desc="Сегмент EEPROM">
                                 ; **** СЕГМЕНТ EEPROM ********************************************
                                 ; .ESEG
                                 ; INFO:       .DB "AVR Thermostat. Written by Sergey Yarkov 22.01.2023"
                                 ;</editor-fold>


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny2313A" register use summary:
x  :   2 y  :   0 z  :   1 r0 :   4 r1 :   2 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   5 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   5 r15:   5 r16: 100 r17:  46 r18:  26 r19:  36 r20:  31 
r21:   8 r22:   0 r23:   4 r24:   5 r25:   3 r26:   3 r27:   3 r28:   0 
r29:   0 r30:   2 r31:   2 
Registers used: 20 out of 35 (57.1%)

"ATtiny2313A" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   3 add   :   4 adiw  :   1 and   :   0 
andi  :   1 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   3 brcs  :   1 break :   0 breq  :   3 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  16 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :  19 cbr   :   3 clc   :   1 
clh   :   0 cli   :   5 cln   :   0 clr   :   6 cls   :   0 clt   :   1 
clv   :   0 clz   :   0 com   :   2 cp    :   0 cpc   :   0 cpi   :  10 
cpse  :   0 dec   :   9 eor   :   0 icall :   0 ijmp  :   0 in    :   2 
inc   :   1 ld    :   0 ldd   :   0 ldi   :  69 lds   :  14 lpm   :   2 
lsl   :   4 lsr   :  10 mov   :  11 movw  :   0 neg   :   1 nop   :   4 
or    :   0 ori   :   0 out   :  19 pop   :  29 push  :  28 rcall :  36 
ret   :  14 reti  :   3 rjmp  :  18 rol   :   4 ror   :   4 sbc   :   1 
sbci  :   1 sbi   :  10 sbic  :   3 sbis  :   5 sbiw  :   1 sbr   :   2 
sbrc  :   1 sbrs  :   1 sec   :   1 seh   :   0 sei   :   5 sen   :   0 
ser   :   0 ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :   2 std   :   0 sts   :  20 sub   :   2 subi  :   1 
swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 56 out of 105 (53.3%)

"ATtiny2313A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0003b0    910     12    922    2048  45.0%
[.dseg] 0x000060 0x00006d      0     13     13     128  10.2%
[.eseg] 0x000000 0x000000      0      0      0     128   0.0%

Assembly complete, 0 errors, 6 warnings
